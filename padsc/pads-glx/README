
=========================================
  Building, Installing, and Testing
   the PADS-Galax Interface 
=========================================

Right now, compilation of the PADS-Galax interface requires access to
the Galax source code.  This is bad!  It _should_ be possible to
compile PADS-Galax by only referring to the Galax binary version
(i.e., the result of running Galax's 'make install').  For now, we
have to continue to refer to the Galax source.

STEP 1: SETUP ENVIRONMENT

  * Edit pads-glx/api/Makefile 

  * Change GALAX to point to Galax source directory.  
    Default is $(HOME)/galax-0.4.0
    (On delenn, GALAX is /home/mff/galax-0.4.0)


STEP 2: Compile

  make world

PADS-GALAX INSTALLATION NOTES
=============================
1. pads/scripts/DO_SETENV.tcsh

   (On squeak, need to run in /bin/sh -- 
    make sure that variables are set correctly)

2. Following vars should be set in env:

   # GALAX
   setenv GALAX_HOME /home/mff/Galax-0.4.0-rh9
   # PADS_HOME
   setenv PADS_HOME /home/mff/pads
   # OCAML
   setenv OCAML_LIB_DIR /home/mff/ocaml-3.08-rh9/lib/ocaml

   # Directory containing Perl compatible RE library (PCRE):
   setenv PCRE_LIB_DIR /home/mff/pcre-4.5-rh9/lib/

3. Compile PADS components 
  
  In padsc, make USE_GALAX=1 

  padsc/include are  padsc/comp independent
  
  This compiles:

  a. Includes in padsc/include
  b. PADS Runtime Library (padsc_lib)
  c. PADS Compiler (padsc_comp)
  d. PADS-Galax Interface (pglx_lib) 

  If you compile the components separately, then run 'make USE_GALAX=1
  install'. 

4. Compile PADS-Galax components

   In pads-glx/api, make world 

5. Build PADS-description dependent query program

   pads/padsc/examples/xml/gen 
   (NOT generated -- these files are written by hand!)

   5a. Sanity check

   Default make rule in pads/padsc/examples/xml does not use -x, so
   necessary to compile .p files separately, so that -x option is
   used. 
   
       In pads/padsc/examples/xml

       make -C yitzhak

       make test_query_enum

       ./<arch>/test_query_enum out3.enum queries/dot.xq

6. Adding new tests to examples/xml

   When adding a new test, must create gen/test_query_XXX.c or
   gen/test_load_XXX.c. 

   Then in examples/xml can run any query on the given PADS data by
   running: 

   ./<arch>/test_query_XXX <data-file> queries/QQQ.xq
  
PADS-GALAX APPLICATION NOTES
============================

Notes on PADS-Galax header files, e.g., test_smart.h:

1. The PADS and Galax initialization code works as follows.

   E.g., in pglx_smart.h, the assumption is that the PADS description
   contains exactly one Parray type.  The PADS startup code creates a
   smart node to represent this array, then passes this smart node to
   Galax's padsDocument() constructor as the node representation.
   The smart node behaves like a phantom root node, which contains a
   sequence of array elements. 

   Previously, the PADS initialization code read the _entire_ data
   source and created a phantom root node that could represent _any_
   PADS type.

  
   If we want to create a PADS node that can represent _any_ PADS type
   (e.g., say a header, followed by a smart array), then in the
   initialization code, first create a document root node: 

     PDCI_MK_TOP_NODE_NORET (doc_node, &PADS_TY(_node_vtable), pads, "doc", &m, &pd, &rep, "main");

   Then initialize this document node as a cached node:
  
     /*  initialize the node to be a cachedNode. */
     doc_node->vt->cachedNode_init(doc_node)

   Now create all the children nodes.  For example, if we had a
   header, followed by a smart node, then first read the header into a
   local variable with header pd, etc:
     
     <header_type>_read(&pads, &header_mask, &header_pd, &header)

   Then create the corresponding header node:
  
     header_node = <header_type>_node_new(doc_node, <name for node>, &header_mask, &header_pd, &header, "element", "main")

   Create the smart node, 

     smart_node = <array_type>_node_new(doc_node, <name for node>, &array_mask, &array_pd, &array, "element", "main")

     <array_type>_smartNode_init(smart_node, MAX_ELTS  EXTRA_ARGS);

    Now initialize the child cache:

    doc_node->child_cache[0] = NULL;
    doc_node->child_cache[1] = header_node;
    doc_node->child_cache[2] = smart_node;

   where TY is type of top-node. 


   (See test_query.h)

PADS-GALAX IMPLEMENTATION NOTES
===============================
This directory contains an implementation of the Galax data model for
PADS.

The data model consists of the following modules and files:

    pads_dm.{ml,mli}  Caml implementation of Galax data model objects.
                      Calls C functions in Pads_c module.

    pads_dm.h         C interface for padsDocument function, which
                      dispatches to Pads_dm to create top-level
                      PADS document node

    pads_dm_stub.c    Implementation of C-to-Caml padsDocument. *NOT* 
		      automatically generated by idl (despite naming similarities).
		      Implementation of assorted c2ml and ml2c conversion functions.

    pads_c.idl        Definitions of "generic" PADS data model C
                      functions.  Called by Pads_dm module.

    pads_pglx.c       Implementation of "generic" PADS data model C
                      functions that dispatches to equivalent PGLX_generic_XXX 
		      functions.

Other files:

    root.idl          Definition of root() function, used to create a root
                      nodeRep for testing pads-glx.

    pads_dummy.c      An implementation of root() and a "dummy" implementation 
		      the generic PGLX_generic_XXX data model functions. 
		      Called by pads_pglx.c.

    test_pads_c.c     A C mainline that tests PADS-Galax interface.
     
    test_idl.ml       A Caml main program that calls PADS data model
                      functions directly.  Just to test IDL.

    test_pads.ml      A Caml main program that tests PADS-Galax interface.



  

a very simple test of the Caml/C IDL
interface.   The IDL mimics the functions that must be provided to
the Galax datamodel.  Here are the files:

  test.idl:  

    The shared types and signatures of C functions available to Caml.

    test.h, test.mli, test.ml are all generated from this IDL file.

  test.c: 

    The implementations of the functions in test.idl.  Note that the
    root() function creates a little "document" and returns a pointer
    to the C nodeRepStruct that represents the root.

    To test this interface with PADS, test.c should be replaced by the
    PADS library that implements these functions for a particular PADS
    data source.  Obviously, the names and possibly signatures of the
    interface functions might have to change to match those produced
    by PADS. 

  test_idl.ml:

    The "main" Caml program, which calls root() to get the root of the
    document and then does a depth first walk over the document,
    printing the name of each node and, if it is a leaf node, its
    typed value. 


To run on delenn, "make run"

~~~~~~~~~~~
Noto Bene!!
~~~~~~~~~~~

  The children() function returns a _null terminated array_ of
  nodeReps (i.e., pointers to node representations).  This means that
  if a node has _no_ children, it _does not_ return NULL.  Instead, it
  returns an array whose first value is NULL.  You will get a SEG
  fault if you return a NULL value to any Caml function expecting an
  array of values.   See test.c, lines 49 & 50, on how to alloc &
  initialize an empty array.  Be sure the PADS children function is
  yielding a NULL terminated array. 